<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PAD Salience Annotation Tool - Prototype</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        header h1 {
            font-size: 1.8rem;
            color: #00d4ff;
            margin-bottom: 5px;
        }

        header p {
            color: #888;
            font-size: 0.9rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr 300px;
            gap: 20px;
        }

        .panel {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
        }

        .panel h2 {
            font-size: 1rem;
            color: #00d4ff;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        /* Left Panel - Sample Selection */
        .sample-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .sample-item {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: #1a1a2e;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .sample-item:hover {
            background: #252550;
        }

        .sample-item.active {
            border-color: #00d4ff;
            background: #252550;
        }

        .sample-item .drug-name {
            font-weight: 600;
            margin-bottom: 3px;
        }

        .sample-item .card-id {
            font-size: 0.75rem;
            color: #888;
        }

        /* Center Panel - Canvas */
        .canvas-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
            border: 3px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }

        #padImage {
            display: block;
            max-width: 100%;
            height: auto;
        }

        #annotationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tool-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tool-btn.primary {
            background: #00d4ff;
            color: #000;
        }

        .tool-btn.primary:hover {
            background: #00b8e6;
        }

        .tool-btn.secondary {
            background: #333;
            color: #eee;
        }

        .tool-btn.secondary:hover {
            background: #444;
        }

        .tool-btn.secondary.active {
            background: #00d4ff;
            color: #000;
        }

        .tool-btn.danger {
            background: #ff4757;
            color: #fff;
        }

        .tool-btn.danger:hover {
            background: #ff3344;
        }

        .tool-btn.recording {
            background: #ff4757;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Right Panel - Annotations & Audio */
        .audio-section {
            margin-bottom: 20px;
        }

        .audio-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: #1a1a2e;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .audio-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #666;
        }

        .audio-indicator.recording {
            background: #ff4757;
            animation: pulse 1s infinite;
        }

        .audio-time {
            font-family: monospace;
            font-size: 1.2rem;
        }

        .annotations-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .annotation-item {
            padding: 12px;
            background: #1a1a2e;
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid #00d4ff;
        }

        .annotation-item .time {
            font-size: 0.75rem;
            color: #00d4ff;
            margin-bottom: 5px;
        }

        .annotation-item .type {
            font-size: 0.8rem;
            color: #888;
        }

        .annotation-item .delete-btn {
            float: right;
            background: none;
            border: none;
            color: #ff4757;
            cursor: pointer;
            font-size: 1rem;
        }

        /* Lane selector */
        .lane-selector {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            margin-top: 15px;
        }

        .lane-btn {
            padding: 8px;
            border: 2px solid #333;
            background: #1a1a2e;
            color: #eee;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .lane-btn:hover {
            border-color: #00d4ff;
        }

        .lane-btn.selected {
            background: #00d4ff;
            color: #000;
            border-color: #00d4ff;
        }

        /* Export section */
        .export-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        /* Color picker */
        .color-picker {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
        }

        .color-option:hover, .color-option.active {
            border-color: #fff;
            transform: scale(1.1);
        }

        /* Instructions */
        .instructions {
            background: #252550;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .instructions h3 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .instructions ul {
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
            color: #aaa;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        .no-image {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 800px;
            height: 450px;
            background: #1a1a2e;
            border-radius: 8px;
            color: #666;
            font-size: 1.2rem;
        }

        /* Lane tooltip that follows cursor */
        .lane-tooltip {
            position: fixed;
            padding: 6px 12px;
            background: rgba(0, 212, 255, 0.95);
            color: #000;
            font-weight: bold;
            font-size: 1rem;
            border-radius: 6px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            transform: translate(-50%, -150%);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .lane-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(0, 212, 255, 0.95);
        }

        .lane-tooltip.outside {
            background: rgba(100, 100, 100, 0.9);
            color: #fff;
        }

        .lane-tooltip.outside::after {
            border-top-color: rgba(100, 100, 100, 0.9);
        }
    </style>
</head>
<body>
    <!-- Lane tooltip that follows cursor -->
    <div class="lane-tooltip" id="laneTooltip">Lane A</div>

    <div class="container">
        <header>
            <h1>PAD Salience Annotation Tool</h1>
            <p>Prototype - Select regions and record expert explanations</p>
        </header>

        <div class="main-content">
            <!-- Left Panel - Sample Selection -->
            <div class="panel">
                <h2>Drug Samples</h2>
                <div class="sample-list" id="sampleList">
                    <!-- Populated by JavaScript -->
                </div>
            </div>

            <!-- Center Panel - Canvas -->
            <div class="panel canvas-container">
                <div class="toolbar">
                    <button class="tool-btn secondary active" id="rectTool" onclick="setTool('rectangle')">
                        <span>[ ]</span> Rectangle
                    </button>
                    <button class="tool-btn secondary" id="freeTool" onclick="setTool('polygon')">
                        <span>⬡</span> Polygon
                    </button>
                    <button class="tool-btn secondary" onclick="undoLast()">
                        Undo
                    </button>
                    <button class="tool-btn danger" onclick="clearAnnotations()">
                        Clear All
                    </button>
                </div>

                <div class="canvas-wrapper" id="canvasWrapper">
                    <div class="no-image" id="noImagePlaceholder">
                        Select a sample from the left panel
                    </div>
                    <img id="padImage" style="display: none;" />
                    <canvas id="annotationCanvas" style="display: none;"></canvas>
                </div>

                <div style="margin-top: 15px;">
                    <label style="color: #888; font-size: 0.85rem;">Drawing Color:</label>
                    <div class="color-picker">
                        <div class="color-option active" style="background: #00d4ff;" onclick="setColor('#00d4ff')"></div>
                        <div class="color-option" style="background: #ff4757;" onclick="setColor('#ff4757')"></div>
                        <div class="color-option" style="background: #2ed573;" onclick="setColor('#2ed573')"></div>
                        <div class="color-option" style="background: #ffa502;" onclick="setColor('#ffa502')"></div>
                        <div class="color-option" style="background: #a55eea;" onclick="setColor('#a55eea')"></div>
                    </div>
                </div>

                <div style="margin-top: 15px; text-align: center;">
                    <p style="color: #666; font-size: 0.8rem;">
                        Lanes (A-L) are detected automatically as you draw
                    </p>
                </div>
            </div>

            <!-- Right Panel - Annotations & Audio -->
            <div class="panel">
                <h2>Audio Recording</h2>
                <div class="audio-section">
                    <div class="audio-status">
                        <div class="audio-indicator" id="audioIndicator"></div>
                        <span class="audio-time" id="audioTime">00:00</span>
                        <span id="audioStatus">Ready</span>
                    </div>
                    <button class="tool-btn primary" id="recordBtn" onclick="toggleRecording()" style="width: 100%;">
                        Start Recording
                    </button>
                </div>

                <h2>Annotations (<span id="annotationCount">0</span>)</h2>
                <div class="annotations-list" id="annotationsList">
                    <p style="color: #666; font-size: 0.85rem;">Draw on the image to create annotations</p>
                </div>

                <div class="export-section">
                    <button class="tool-btn primary" onclick="exportSession()" style="width: 100%;">
                        Export Session Data
                    </button>
                    <button class="tool-btn secondary" onclick="startNewSession()" style="width: 100%; margin-top: 10px;">
                        Start New Session
                    </button>
                </div>

                <div class="instructions">
                    <h3>How to use:</h3>
                    <ul>
                        <li>1. Select a drug sample</li>
                        <li>2. Click "Start Recording"</li>
                        <li>3. Draw regions + explain</li>
                        <li>4. Click "Export" to save</li>
                        <li>5. "New Session" for next drug</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State
        let currentSample = null;
        let currentTool = 'rectangle';
        let currentColor = '#00d4ff';
        // selectedLanes removed - now using auto-detection
        let annotations = [];
        let isDrawing = false;
        let startX, startY;
        let polygonPoints = [];

        // Audio state
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let audioTimerInterval = null;

        // Canvas elements
        const canvas = document.getElementById('annotationCanvas');
        const ctx = canvas.getContext('2d');
        const padImage = document.getElementById('padImage');

        // Drawing timestamp tracking
        let drawingStartTime = null;

        // Lane detection configuration (for processed images ~730px wide)
        // Lanes A-L are arranged in vertical columns
        // Calibrated based on actual PAD image layout
        const LANE_CONFIG = {
            // X boundaries as percentage of image width
            // Calibrated for standard processed PAD images (730px wide)
            startPercent: 0.082,  // ~60px - where lanes start (after QR code)
            endPercent: 0.986,    // ~720px - where lanes end
            lanes: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']
        };

        // Get lane boundaries for current image
        function getLaneBoundaries() {
            if (!canvas.width) return [];

            const startX = canvas.width * LANE_CONFIG.startPercent;
            const endX = canvas.width * LANE_CONFIG.endPercent;
            const laneWidth = (endX - startX) / LANE_CONFIG.lanes.length;

            return LANE_CONFIG.lanes.map((lane, index) => ({
                lane: lane,
                x1: startX + (index * laneWidth),
                x2: startX + ((index + 1) * laneWidth)
            }));
        }

        // Auto-detect which lanes an annotation overlaps with
        function detectLanes(x1, x2) {
            const boundaries = getLaneBoundaries();
            const detectedLanes = [];

            for (const boundary of boundaries) {
                // Check if annotation overlaps with this lane
                if (x2 >= boundary.x1 && x1 <= boundary.x2) {
                    detectedLanes.push(boundary.lane);
                }
            }

            return detectedLanes;
        }

        // Sample data - will be loaded from manifest
        let samples = [];

        // Load manifest
        async function loadManifest() {
            try {
                const response = await fetch('/sample_images/manifest.json');
                samples = await response.json();
                renderSampleList();
            } catch (error) {
                console.error('Error loading manifest:', error);
            }
        }

        function renderSampleList() {
            const list = document.getElementById('sampleList');
            list.innerHTML = samples.map((sample, index) => `
                <div class="sample-item" onclick="selectSample(${index})" id="sample-${index}">
                    <div class="drug-name">${sample.drug_name_display || sample.drug_name}</div>
                    <div class="card-id">Card ID: ${sample.card_id}</div>
                </div>
            `).join('');
        }

        function selectSample(index) {
            // Check if there's an active session with unsaved work
            if (currentSample && (annotations.length > 0 || audioChunks.length > 0)) {
                alert('You have unsaved annotations.\n\nPlease "Export Session Data" first, then use "Start New Session" to change drugs.');
                return;
            }

            // If already have a sample selected (but no annotations), warn about focused session
            if (currentSample && currentSample !== samples[index]) {
                if (!confirm('Start a new session with a different drug?\n\nThis will clear any current work.')) {
                    return;
                }
            }

            // Update selection UI
            document.querySelectorAll('.sample-item').forEach(el => el.classList.remove('active'));
            document.getElementById(`sample-${index}`).classList.add('active');

            currentSample = samples[index];

            // Load image
            document.getElementById('noImagePlaceholder').style.display = 'none';
            padImage.style.display = 'block';
            canvas.style.display = 'block';

            padImage.onload = () => {
                // Set canvas size to match image
                canvas.width = padImage.naturalWidth;
                canvas.height = padImage.naturalHeight;
                canvas.style.width = padImage.width + 'px';
                canvas.style.height = padImage.height + 'px';

                // Clear and redraw annotations
                redrawAnnotations();
            };

            // Load image from server
            padImage.src = `/sample_images/${currentSample.filename}`;

            // Clear annotations for new sample
            annotations = [];
            audioChunks = [];
            updateAnnotationsList();
        }

        function setTool(tool) {
            currentTool = tool;
            document.getElementById('rectTool').classList.toggle('active', tool === 'rectangle');
            document.getElementById('freeTool').classList.toggle('active', tool === 'polygon');
        }

        function setColor(color) {
            currentColor = color;
            document.querySelectorAll('.color-option').forEach(el => {
                el.classList.toggle('active', el.style.background === color);
            });
        }

        // Lane selection functions removed - now using auto-detection

        // Canvas drawing
        canvas.addEventListener('mousedown', (e) => {
            if (!currentSample) return;

            isDrawing = true;

            // Capture start timestamp
            drawingStartTime = isRecording ? (Date.now() - recordingStartTime) : null;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            startX = (e.clientX - rect.left) * scaleX;
            startY = (e.clientY - rect.top) * scaleY;

            if (currentTool === 'polygon') {
                polygonPoints = [{x: startX, y: startY}];
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const currentX = (e.clientX - rect.left) * scaleX;
            const currentY = (e.clientY - rect.top) * scaleY;

            redrawAnnotations();

            ctx.strokeStyle = currentColor;
            ctx.lineWidth = 3;

            if (currentTool === 'rectangle') {
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
                ctx.setLineDash([]);
            } else {
                polygonPoints.push({x: currentX, y: currentY});
                ctx.beginPath();
                ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
                for (let point of polygonPoints) {
                    ctx.lineTo(point.x, point.y);
                }
                ctx.closePath(); // Close the polygon
                ctx.stroke();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDrawing) return;
            isDrawing = false;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const endX = (e.clientX - rect.left) * scaleX;
            const endY = (e.clientY - rect.top) * scaleY;

            // Capture end timestamp
            const timestampEnd = isRecording ? (Date.now() - recordingStartTime) : null;

            // Auto-detect lanes based on annotation position
            let autoDetectedLanes;
            if (currentTool === 'rectangle') {
                autoDetectedLanes = detectLanes(Math.min(startX, endX), Math.max(startX, endX));
            } else {
                // For polygon, find X bounds from all points
                const xCoords = polygonPoints.map(p => p.x);
                autoDetectedLanes = detectLanes(Math.min(...xCoords), Math.max(...xCoords));
            }

            let annotation;
            if (currentTool === 'rectangle') {
                annotation = {
                    id: Date.now(),
                    type: 'rectangle',
                    color: currentColor,
                    lanes: autoDetectedLanes,
                    timestamp_start_ms: drawingStartTime,
                    timestamp_end_ms: timestampEnd,
                    bbox: {
                        x: Math.min(startX, endX),
                        y: Math.min(startY, endY),
                        width: Math.abs(endX - startX),
                        height: Math.abs(endY - startY)
                    },
                    // Normalized coordinates (0-999)
                    bbox_normalized: {
                        x1: Math.round(Math.min(startX, endX) / canvas.width * 999),
                        y1: Math.round(Math.min(startY, endY) / canvas.height * 999),
                        x2: Math.round(Math.max(startX, endX) / canvas.width * 999),
                        y2: Math.round(Math.max(startY, endY) / canvas.height * 999)
                    }
                };
            } else {
                annotation = {
                    id: Date.now(),
                    type: 'polygon',
                    color: currentColor,
                    lanes: autoDetectedLanes,
                    timestamp_start_ms: drawingStartTime,
                    timestamp_end_ms: timestampEnd,
                    points: polygonPoints,
                    // Normalized points
                    points_normalized: polygonPoints.map(p => ({
                        x: Math.round(p.x / canvas.width * 999),
                        y: Math.round(p.y / canvas.height * 999)
                    }))
                };
            }

            // Only save if significant size
            if (currentTool === 'rectangle' && annotation.bbox.width > 10 && annotation.bbox.height > 10) {
                annotations.push(annotation);
            } else if (currentTool === 'polygon' && polygonPoints.length > 5) {
                annotations.push(annotation);
            }

            // Reset drawing start time
            drawingStartTime = null;

            redrawAnnotations();
            updateAnnotationsList();
            polygonPoints = [];
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDrawing) {
                isDrawing = false;
                polygonPoints = [];
                redrawAnnotations();
            }
            // Hide tooltip
            hideLaneTooltip();
        });

        // Real-time lane detection with cursor tooltip
        canvas.addEventListener('mousemove', (e) => {
            if (!currentSample) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scaleX;

            // Detect lane at cursor position
            const lanes = detectLanes(x, x);

            // Show tooltip near cursor
            showLaneTooltip(e.clientX, e.clientY, lanes);
        });

        // Lane tooltip functions
        function showLaneTooltip(mouseX, mouseY, lanes) {
            const tooltip = document.getElementById('laneTooltip');

            if (lanes.length > 0) {
                tooltip.textContent = `Lane ${lanes.join(', ')}`;
                tooltip.classList.remove('outside');
            } else {
                tooltip.textContent = 'Outside';
                tooltip.classList.add('outside');
            }

            tooltip.style.left = mouseX + 'px';
            tooltip.style.top = mouseY + 'px';
            tooltip.style.display = 'block';
        }

        function hideLaneTooltip() {
            document.getElementById('laneTooltip').style.display = 'none';
        }

        function redrawAnnotations() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let ann of annotations) {
                ctx.strokeStyle = ann.color;
                ctx.lineWidth = 3;

                if (ann.type === 'rectangle') {
                    ctx.strokeRect(ann.bbox.x, ann.bbox.y, ann.bbox.width, ann.bbox.height);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(ann.points[0].x, ann.points[0].y);
                    for (let point of ann.points) {
                        ctx.lineTo(point.x, point.y);
                    }
                    ctx.closePath(); // Close the polygon
                    ctx.stroke();
                }
            }
        }

        function updateAnnotationsList() {
            const list = document.getElementById('annotationsList');
            document.getElementById('annotationCount').textContent = annotations.length;

            if (annotations.length === 0) {
                list.innerHTML = '<p style="color: #666; font-size: 0.85rem;">Draw on the image to create annotations</p>';
                return;
            }

            list.innerHTML = annotations.map((ann, index) => `
                <div class="annotation-item">
                    <button class="delete-btn" onclick="deleteAnnotation(${index})">x</button>
                    <div class="time">${formatTimeRange(ann.timestamp_start_ms, ann.timestamp_end_ms)}</div>
                    <div class="type">${ann.type} - Lanes: ${ann.lanes.length > 0 ? ann.lanes.join(', ') : 'none'}</div>
                </div>
            `).join('');
        }

        function deleteAnnotation(index) {
            annotations.splice(index, 1);
            redrawAnnotations();
            updateAnnotationsList();
        }

        function undoLast() {
            if (annotations.length > 0) {
                annotations.pop();
                redrawAnnotations();
                updateAnnotationsList();
            }
        }

        function clearAnnotations() {
            if (confirm('Clear all annotations?')) {
                annotations = [];
                redrawAnnotations();
                updateAnnotationsList();
            }
        }

        // Audio recording
        async function toggleRecording() {
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = (e) => {
                        audioChunks.push(e.data);
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    recordingStartTime = Date.now();

                    document.getElementById('recordBtn').textContent = 'Stop Recording';
                    document.getElementById('recordBtn').classList.add('recording');
                    document.getElementById('audioIndicator').classList.add('recording');
                    document.getElementById('audioStatus').textContent = 'Recording...';

                    audioTimerInterval = setInterval(updateAudioTimer, 1000);
                } catch (error) {
                    alert('Could not access microphone: ' + error.message);
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;

                clearInterval(audioTimerInterval);

                document.getElementById('recordBtn').textContent = 'Start Recording';
                document.getElementById('recordBtn').classList.remove('recording');
                document.getElementById('audioIndicator').classList.remove('recording');
                document.getElementById('audioStatus').textContent = 'Stopped';

                // Stop all tracks
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        }

        function updateAudioTimer() {
            if (!recordingStartTime) return;
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('audioTime').textContent = `${minutes}:${seconds}`;
        }

        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function formatTimeRange(startMs, endMs) {
            if (startMs === null || endMs === null) {
                return 'No audio timestamp';
            }
            return `${formatTime(startMs)} → ${formatTime(endMs)}`;
        }

        // Export
        async function exportSession() {
            if (!currentSample) {
                alert('Please select a sample first');
                return;
            }

            if (annotations.length === 0) {
                alert('No annotations to export. Draw some regions first.');
                return;
            }

            // Stop recording if still active
            if (isRecording) {
                await stopRecordingForExport();
            }

            const sessionData = {
                session_id: `session_${Date.now()}`,
                timestamp: new Date().toISOString(),
                sample: currentSample,
                image_dimensions: {
                    width: canvas.width,
                    height: canvas.height
                },
                annotations: JSON.parse(JSON.stringify(annotations)), // Deep copy
                audio: null
            };

            // If we have audio, include it
            if (audioChunks.length > 0) {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const reader = new FileReader();
                reader.readAsDataURL(audioBlob);

                reader.onloadend = () => {
                    sessionData.audio = {
                        format: 'webm',
                        data_base64: reader.result.split(',')[1],
                        duration_ms: sessionData.recording_duration_ms || null
                    };

                    downloadSession(sessionData);
                };
            } else {
                downloadSession(sessionData);
            }
        }

        // Stop recording and wait for it to finish
        function stopRecordingForExport() {
            return new Promise((resolve) => {
                if (!isRecording || !mediaRecorder) {
                    resolve();
                    return;
                }

                const duration = Date.now() - recordingStartTime;

                mediaRecorder.onstop = () => {
                    isRecording = false;
                    clearInterval(audioTimerInterval);

                    document.getElementById('recordBtn').textContent = 'Start Recording';
                    document.getElementById('recordBtn').classList.remove('recording');
                    document.getElementById('audioIndicator').classList.remove('recording');
                    document.getElementById('audioStatus').textContent = 'Stopped (exported)';

                    // Store duration for export
                    window.lastRecordingDuration = duration;

                    resolve();
                };

                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            });
        }

        async function downloadSession(data) {
            try {
                // Send to server
                const response = await fetch('/api/save-annotation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const result = await response.json();

                // Show confirmation
                alert(`Saved ${data.annotations.length} annotations${result.audio_saved ? ' with audio' : ''} to server.\n\nTotal sessions: ${result.total_sessions}\n\nAnnotations are preserved - you can continue or start a new session.`);

            } catch (error) {
                console.error('Error saving to server:', error);

                // Fallback: download as file
                if (confirm(`Could not save to server: ${error.message}\n\nDownload as local file instead?`)) {
                    const json = JSON.stringify(data, null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `pad_annotation_${data.sample.drug_name}_${Date.now()}.json`;
                    a.click();

                    URL.revokeObjectURL(url);
                }
            }
        }

        // Start new session (clear everything)
        function startNewSession() {
            if (annotations.length > 0 || audioChunks.length > 0) {
                if (!confirm('This will clear all annotations and audio. Continue?')) {
                    return;
                }
            }

            // Stop recording if active
            if (isRecording) {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;
                clearInterval(audioTimerInterval);
            }

            // Reset everything
            annotations = [];
            audioChunks = [];
            recordingStartTime = null;

            // Reset UI
            document.getElementById('recordBtn').textContent = 'Start Recording';
            document.getElementById('recordBtn').classList.remove('recording');
            document.getElementById('audioIndicator').classList.remove('recording');
            document.getElementById('audioStatus').textContent = 'Ready';
            document.getElementById('audioTime').textContent = '00:00';

            redrawAnnotations();
            updateAnnotationsList();
        }

        // Initialize
        loadManifest();
    </script>
</body>
</html>
