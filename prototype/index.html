<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PAD Annotation - Eye-tracking (Fullscreen)</title>
    <style>
        /* CSS Custom Properties - loaded from config.yaml */
        :root {
            --tag-size: 60px;
            --tag-margin: 0px;
            --tag-offset: 60px;
            --tracked-padding: 0px;
            --sidebar-width: 240px;
            --bg-color: #1a1a2e;
            --sidebar-color: #16213e;
            --pad-width: 730px;
            --pad-height: auto;
            --pad-max-height: 85vh;
            --pad-border: 0px;
            --pad-border-radius: 0px;
            --pad-border-color: #333333;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: #eee;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Main Layout - 2 columns only: tracked area + sidebar */
        .main-layout {
            display: grid;
            grid-template-columns: 1fr var(--sidebar-width);
            height: 100vh;
            overflow: hidden;
        }

        /* Tracked Area - ONLY tags + PAD image */
        .tracked-area {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: calc(var(--tag-offset) + var(--tracked-padding)) 10px;
            background: var(--bg-color);
            overflow: auto;
        }

        .apriltag-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .apriltag {
            position: absolute;
            width: var(--tag-size);
            height: var(--tag-size);
            background: white;
            padding: 4px;
            z-index: 100;
        }

        .apriltag img {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .apriltag.top-left {
            top: calc(-1 * var(--tag-offset));
            left: calc(-1 * var(--tag-offset));
        }

        .apriltag.top-right {
            top: calc(-1 * var(--tag-offset));
            right: calc(-1 * var(--tag-offset));
        }

        .apriltag.bottom-left {
            bottom: calc(-1 * var(--tag-offset));
            left: calc(-1 * var(--tag-offset));
        }

        .apriltag.bottom-right {
            bottom: calc(-1 * var(--tag-offset));
            right: calc(-1 * var(--tag-offset));
        }

        /* Hide tags and badge when eye-tracking is disabled */
        .eyetracking-disabled .apriltag {
            display: none;
        }

        .eyetracking-disabled .tracked-area {
            padding: 10px;
        }

        .eyetracking-disabled .eyetracking-badge {
            display: none;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
            border: var(--pad-border) solid var(--pad-border-color);
            border-radius: var(--pad-border-radius);
            overflow: hidden;
        }

        #padImage {
            display: block;
            width: var(--pad-width);
            height: var(--pad-height);
        }

        #annotationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .no-image {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 800px;
            height: 450px;
            background: #252550;
            border-radius: 8px;
            color: #666;
            font-size: 1.1rem;
            text-align: center;
            padding: 20px;
        }

        /* Right Sidebar - contains everything */
        .sidebar {
            display: flex;
            flex-direction: column;
            background: var(--sidebar-color);
            border-left: 1px solid #333;
            padding: 15px;
            overflow: hidden;
            height: 100%;
        }

        .sidebar-header {
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid #333;
        }

        .sidebar-header h1 {
            font-size: 1.1rem;
            color: #00d4ff;
            margin-bottom: 8px;
        }

        .eyetracking-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: #2ed573;
            color: #000;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .eyetracking-badge .dot {
            width: 6px;
            height: 6px;
            background: #fff;
            border-radius: 50%;
        }

        .sidebar h3 {
            font-size: 0.8rem;
            color: #00d4ff;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
        }

        /* Tools Section */
        .tools-section {
            margin-bottom: 15px;
        }

        .tool-buttons {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
        }

        .tool-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .tool-btn.icon-btn {
            padding: 6px;
            width: 28px;
            height: 28px;
            font-size: 0.95rem;
        }

        .tool-btn.rec-btn {
            padding: 4px 10px;
            font-size: 0.7rem;
        }

        .tool-btn.secondary {
            background: #333;
            color: #eee;
        }

        .tool-btn.secondary:hover {
            background: #444;
        }

        .tool-btn.secondary.active {
            background: #00d4ff;
            color: #000;
        }

        .tool-btn.danger {
            background: #ff4757;
            color: #fff;
        }

        .tool-btn.danger:hover {
            background: #ff3344;
        }

        .tool-btn.primary {
            background: #00d4ff;
            color: #000;
        }

        .tool-btn.primary:hover {
            background: #00b8e6;
        }

        .tool-btn.recording {
            background: #ff4757;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .color-picker {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .color-picker-label {
            font-size: 0.7rem;
            color: #888;
            margin-right: 4px;
        }

        .color-option {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-option:hover, .color-option.active {
            border-color: #fff;
            transform: scale(1.1);
        }

        /* Audio Section */
        .audio-section {
            margin-bottom: 15px;
        }

        .audio-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .audio-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #666;
            flex-shrink: 0;
        }

        .audio-indicator.recording {
            background: #ff4757;
            animation: pulse 1s infinite;
        }

        .audio-time {
            font-family: monospace;
            font-size: 1.1rem;
        }

        .divider {
            height: 1px;
            background: #333;
            margin: 12px 0;
        }

        /* Annotations Section */
        .annotations-section {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .annotations-list {
            flex: 1;
            overflow-y: auto;
            min-height: 80px;
        }

        .annotation-item {
            padding: 8px;
            background: #1a1a2e;
            border-radius: 6px;
            margin-bottom: 5px;
            border-left: 3px solid #00d4ff;
            font-size: 0.75rem;
        }

        .annotation-item .time {
            font-size: 0.65rem;
            color: #00d4ff;
            margin-bottom: 2px;
        }

        .annotation-item .type {
            font-size: 0.7rem;
            color: #888;
        }

        .annotation-item .delete-btn {
            float: right;
            background: none;
            border: none;
            color: #ff4757;
            cursor: pointer;
            font-size: 0.85rem;
            padding: 0;
            line-height: 1;
        }

        /* Done Section */
        .done-section {
            margin-top: auto;
            padding-top: 12px;
        }

        .done-btn {
            width: 100%;
            padding: 12px;
            background: #2ed573;
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .done-btn:hover {
            background: #26c066;
        }

        .new-session-btn {
            width: 100%;
            padding: 8px;
            margin-top: 8px;
            background: #333;
            color: #eee;
            border: none;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .new-session-btn:hover {
            background: #444;
        }

        /* Lane tooltip */
        .lane-tooltip {
            position: fixed;
            padding: 6px 12px;
            background: rgba(0, 212, 255, 0.95);
            color: #000;
            font-weight: bold;
            font-size: 1rem;
            border-radius: 6px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            transform: translate(-50%, -150%);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .lane-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(0, 212, 255, 0.95);
        }

        .lane-tooltip.outside {
            background: rgba(100, 100, 100, 0.9);
            color: #fff;
        }

        .lane-tooltip.outside::after {
            border-top-color: rgba(100, 100, 100, 0.9);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        .empty-state {
            color: #666;
            font-size: 0.75rem;
            text-align: center;
            padding: 15px 10px;
        }

        /* Settings button */
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-btn {
            background: none;
            border: 1px solid #444;
            color: #888;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-btn:hover {
            background: #333;
            color: #fff;
            border-color: #555;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal {
            background: #1e1e3f;
            border-radius: 12px;
            width: 400px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #16213e;
            border-bottom: 1px solid #333;
        }

        .modal-header h2 {
            font-size: 1.1rem;
            color: #00d4ff;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover {
            color: #fff;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            max-height: 60vh;
        }

        .modal-footer {
            display: flex;
            justify-content: space-between;
            padding: 15px 20px;
            background: #16213e;
            border-top: 1px solid #333;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .settings-section h3 {
            font-size: 0.85rem;
            color: #00d4ff;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
        }

        .setting-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .setting-row:last-child {
            margin-bottom: 0;
        }

        .setting-row label {
            font-size: 0.8rem;
            color: #aaa;
            min-width: 80px;
        }

        .setting-row input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #333;
            border-radius: 3px;
            cursor: pointer;
        }

        .setting-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .setting-row input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .setting-value {
            font-size: 0.8rem;
            color: #00d4ff;
            min-width: 50px;
            text-align: right;
            font-family: monospace;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .checkbox-row label {
            font-size: 0.8rem;
            color: #aaa;
            min-width: auto;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="lane-tooltip" id="laneTooltip">Lane A</div>

    <div class="main-layout">
        <!-- Tracked Area - ONLY AprilTags + PAD Image -->
        <div class="tracked-area">
            <div class="apriltag-container" id="apriltagContainer">
                <div class="apriltag top-left">
                    <img src="/assets/apriltags/tag36h11_0.png" alt="AprilTag 0">
                </div>
                <div class="apriltag top-right">
                    <img src="/assets/apriltags/tag36h11_3.png" alt="AprilTag 3">
                </div>
                <div class="apriltag bottom-left">
                    <img src="/assets/apriltags/tag36h11_7.png" alt="AprilTag 7">
                </div>
                <div class="apriltag bottom-right">
                    <img src="/assets/apriltags/tag36h11_4.png" alt="AprilTag 4">
                </div>

                <div class="canvas-wrapper" id="canvasWrapper">
                    <div class="no-image" id="noImagePlaceholder">
                        Loading PAD image...
                    </div>
                    <img id="padImage" style="display: none;" />
                    <canvas id="annotationCanvas" style="display: none;"></canvas>
                </div>
            </div>
        </div>

        <!-- Right Sidebar - All controls -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="header-row">
                    <h1>PAD Annotation</h1>
                    <button class="settings-btn" onclick="openSettings()" title="Settings">⚙</button>
                </div>
                <span class="eyetracking-badge"><span class="dot"></span>Eye-tracking</span>
            </div>

            <div class="tools-section">
                <h3>Tools</h3>
                <div class="tool-buttons">
                    <button class="tool-btn icon-btn secondary active" id="rectTool" onclick="setTool('rectangle')" title="Rectangle">
                        ▢
                    </button>
                    <button class="tool-btn icon-btn secondary" id="freeTool" onclick="setTool('polygon')" title="Polygon">
                        ⬠
                    </button>
                    <button class="tool-btn icon-btn secondary" onclick="undoLast()" title="Undo">
                        ↩
                    </button>
                    <button class="tool-btn icon-btn danger" onclick="clearAnnotations()" title="Clear All">
                        ✕
                    </button>
                </div>
                <div class="color-picker">
                    <span class="color-picker-label">Color:</span>
                    <div class="color-option active" style="background: #00d4ff;" onclick="setColor('#00d4ff')" title="Cyan"></div>
                    <div class="color-option" style="background: #ff4757;" onclick="setColor('#ff4757')" title="Red"></div>
                    <div class="color-option" style="background: #2ed573;" onclick="setColor('#2ed573')" title="Green"></div>
                    <div class="color-option" style="background: #ffa502;" onclick="setColor('#ffa502')" title="Orange"></div>
                    <div class="color-option" style="background: #a55eea;" onclick="setColor('#a55eea')" title="Purple"></div>
                </div>
            </div>

            <div class="divider"></div>

            <div class="audio-section">
                <h3>Recording</h3>
                <div class="audio-status">
                    <div class="audio-indicator" id="audioIndicator"></div>
                    <span class="audio-time" id="audioTime">00:00</span>
                    <button class="tool-btn primary rec-btn" id="recordBtn" onclick="toggleRecording()" title="Start/Stop Recording">
                        ● Rec
                    </button>
                </div>
            </div>

            <div class="divider"></div>

            <div class="annotations-section">
                <h3>Annotations (<span id="annotationCount">0</span>)</h3>
                <div class="annotations-list" id="annotationsList">
                    <p class="empty-state">Draw on the image to create annotations</p>
                </div>
            </div>

            <div class="done-section">
                <button class="done-btn" id="doneBtn" onclick="exportSession()">
                    DONE
                </button>
                <button class="new-session-btn" onclick="startNewSession()">
                    New Session
                </button>
            </div>
        </aside>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="modal-close" onclick="closeSettings()">×</button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <h3>Eye-Tracking</h3>
                    <div class="setting-row">
                        <div class="checkbox-row">
                            <input type="checkbox" id="eyetrackingEnabled" checked>
                            <label for="eyetrackingEnabled">Enable AprilTag markers</label>
                        </div>
                    </div>
                </div>

                <div class="settings-section" id="apriltagSettings">
                    <h3>AprilTags</h3>
                    <div class="setting-row">
                        <label>Size</label>
                        <input type="range" id="tagSize" min="30" max="120" value="60">
                        <span class="setting-value" id="tagSizeValue">60px</span>
                    </div>
                    <div class="setting-row">
                        <label>Margin</label>
                        <input type="range" id="tagMargin" min="0" max="30" value="0">
                        <span class="setting-value" id="tagMarginValue">0px</span>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>PAD Image</h3>
                    <div class="setting-row">
                        <label>Width</label>
                        <input type="range" id="padWidth" min="400" max="1200" value="730">
                        <span class="setting-value" id="padWidthValue">730px</span>
                    </div>
                    <div class="setting-row">
                        <label>Height</label>
                        <div class="checkbox-row">
                            <input type="checkbox" id="padHeightAuto" checked>
                            <label for="padHeightAuto">Auto (keep aspect ratio)</label>
                        </div>
                    </div>
                    <div class="setting-row" id="padHeightRow" style="display: none;">
                        <label>Height</label>
                        <input type="range" id="padHeight" min="400" max="1500" value="1220">
                        <span class="setting-value" id="padHeightValue">1220px</span>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>Layout</h3>
                    <div class="setting-row">
                        <label>Tracked Area Padding</label>
                        <input type="range" id="trackedPadding" min="0" max="50" value="0">
                        <span class="setting-value" id="trackedPaddingValue">0px</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="tool-btn secondary" onclick="resetSettings()">Reset to Default</button>
                <button class="tool-btn primary" onclick="closeSettings()">Done</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let currentSample = null;
        let currentTool = 'rectangle';
        let currentColor = '#00d4ff';
        let annotations = [];
        let isDrawing = false;
        let startX, startY;
        let polygonPoints = [];

        // Audio state
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let audioTimerInterval = null;

        // Canvas elements
        const canvas = document.getElementById('annotationCanvas');
        const ctx = canvas.getContext('2d');
        const padImage = document.getElementById('padImage');

        // Drawing timestamp tracking
        let drawingStartTime = null;

        // Lane detection configuration (will be updated from config.yaml)
        let LANE_CONFIG = {
            startPercent: 0.082,
            endPercent: 0.986,
            lanes: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']
        };

        // Load configuration from server
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();

                // Apply CSS variables
                const root = document.documentElement;

                if (config.apriltags) {
                    const tagSize = config.apriltags.size_px || 60;
                    const tagMargin = config.apriltags.margin_px || 0;
                    root.style.setProperty('--tag-size', `${tagSize}px`);
                    root.style.setProperty('--tag-margin', `${tagMargin}px`);
                    root.style.setProperty('--tag-offset', `${tagSize + tagMargin}px`);

                    // Enable/disable eye-tracking mode
                    if (config.apriltags.enabled === false) {
                        document.body.classList.add('eyetracking-disabled');
                    } else {
                        document.body.classList.remove('eyetracking-disabled');
                    }
                }

                if (config.layout) {
                    if (config.layout.sidebar_width_px) {
                        root.style.setProperty('--sidebar-width', `${config.layout.sidebar_width_px}px`);
                    }
                    if (config.layout.tracked_padding_px !== undefined) {
                        root.style.setProperty('--tracked-padding', `${config.layout.tracked_padding_px}px`);
                    }
                    if (config.layout.background_color) {
                        root.style.setProperty('--bg-color', config.layout.background_color);
                    }
                    if (config.layout.sidebar_color) {
                        root.style.setProperty('--sidebar-color', config.layout.sidebar_color);
                    }
                }

                if (config.pad_image) {
                    if (config.pad_image.width_px) {
                        root.style.setProperty('--pad-width', `${config.pad_image.width_px}px`);
                    } else {
                        root.style.setProperty('--pad-width', 'auto');
                    }
                    if (config.pad_image.height_px) {
                        root.style.setProperty('--pad-height', `${config.pad_image.height_px}px`);
                    } else {
                        root.style.setProperty('--pad-height', 'auto');
                    }
                    if (config.pad_image.max_height_vh) {
                        root.style.setProperty('--pad-max-height', `${config.pad_image.max_height_vh}vh`);
                    }
                    if (config.pad_image.border_px !== undefined) {
                        root.style.setProperty('--pad-border', `${config.pad_image.border_px}px`);
                    }
                    if (config.pad_image.border_radius_px !== undefined) {
                        root.style.setProperty('--pad-border-radius', `${config.pad_image.border_radius_px}px`);
                    }
                    if (config.pad_image.border_color) {
                        root.style.setProperty('--pad-border-color', config.pad_image.border_color);
                    }
                }

                if (config.lanes) {
                    LANE_CONFIG = {
                        startPercent: config.lanes.start_percent || LANE_CONFIG.startPercent,
                        endPercent: config.lanes.end_percent || LANE_CONFIG.endPercent,
                        lanes: config.lanes.labels || LANE_CONFIG.lanes
                    };
                }

                console.log('Config loaded:', config);
            } catch (error) {
                console.warn('Could not load config, using defaults:', error);
            }
        }

        function getLaneBoundaries() {
            if (!canvas.width) return [];
            const startX = canvas.width * LANE_CONFIG.startPercent;
            const endX = canvas.width * LANE_CONFIG.endPercent;
            const laneWidth = (endX - startX) / LANE_CONFIG.lanes.length;
            return LANE_CONFIG.lanes.map((lane, index) => ({
                lane: lane,
                x1: startX + (index * laneWidth),
                x2: startX + ((index + 1) * laneWidth)
            }));
        }

        function detectLanes(x1, x2) {
            const boundaries = getLaneBoundaries();
            const detectedLanes = [];
            for (const boundary of boundaries) {
                if (x2 >= boundary.x1 && x1 <= boundary.x2) {
                    detectedLanes.push(boundary.lane);
                }
            }
            return detectedLanes;
        }

        let samples = [];

        async function loadManifest() {
            try {
                const response = await fetch('/sample_images/manifest.json');
                samples = await response.json();
                if (samples.length > 0) {
                    loadSample(0);
                }
            } catch (error) {
                console.error('Error loading manifest:', error);
                document.getElementById('noImagePlaceholder').textContent =
                    'Error loading samples. Please check server.';
            }
        }

        function loadSample(index) {
            currentSample = samples[index];
            document.getElementById('noImagePlaceholder').style.display = 'none';
            padImage.style.display = 'block';
            canvas.style.display = 'block';

            padImage.onload = () => {
                canvas.width = padImage.naturalWidth;
                canvas.height = padImage.naturalHeight;
                canvas.style.width = padImage.width + 'px';
                canvas.style.height = padImage.height + 'px';
                redrawAnnotations();
            };

            padImage.src = `/sample_images/${currentSample.filename}`;
            annotations = [];
            audioChunks = [];
            updateAnnotationsList();
        }

        function setTool(tool) {
            currentTool = tool;
            document.getElementById('rectTool').classList.toggle('active', tool === 'rectangle');
            document.getElementById('freeTool').classList.toggle('active', tool === 'polygon');
        }

        function setColor(color) {
            currentColor = color;
            document.querySelectorAll('.color-option').forEach(el => {
                el.classList.toggle('active', el.style.background === color);
            });
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!currentSample) return;
            isDrawing = true;
            drawingStartTime = isRecording ? (Date.now() - recordingStartTime) : null;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            startX = (e.clientX - rect.left) * scaleX;
            startY = (e.clientY - rect.top) * scaleY;
            if (currentTool === 'polygon') {
                polygonPoints = [{x: startX, y: startY}];
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!currentSample) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scaleX;
            const lanes = detectLanes(x, x);
            showLaneTooltip(e.clientX, e.clientY, lanes);

            if (!isDrawing) return;
            const scaleY = canvas.height / rect.height;
            const currentX = (e.clientX - rect.left) * scaleX;
            const currentY = (e.clientY - rect.top) * scaleY;
            redrawAnnotations();
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = 3;

            if (currentTool === 'rectangle') {
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
                ctx.setLineDash([]);
            } else {
                polygonPoints.push({x: currentX, y: currentY});
                ctx.beginPath();
                ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
                for (let point of polygonPoints) {
                    ctx.lineTo(point.x, point.y);
                }
                ctx.closePath();
                ctx.stroke();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDrawing) return;
            isDrawing = false;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const endX = (e.clientX - rect.left) * scaleX;
            const endY = (e.clientY - rect.top) * scaleY;
            const timestampEnd = isRecording ? (Date.now() - recordingStartTime) : null;

            let autoDetectedLanes;
            if (currentTool === 'rectangle') {
                autoDetectedLanes = detectLanes(Math.min(startX, endX), Math.max(startX, endX));
            } else {
                const xCoords = polygonPoints.map(p => p.x);
                autoDetectedLanes = detectLanes(Math.min(...xCoords), Math.max(...xCoords));
            }

            let annotation;
            if (currentTool === 'rectangle') {
                annotation = {
                    id: Date.now(),
                    type: 'rectangle',
                    color: currentColor,
                    lanes: autoDetectedLanes,
                    timestamp_start_ms: drawingStartTime,
                    timestamp_end_ms: timestampEnd,
                    bbox: {
                        x: Math.min(startX, endX),
                        y: Math.min(startY, endY),
                        width: Math.abs(endX - startX),
                        height: Math.abs(endY - startY)
                    },
                    bbox_normalized: {
                        x1: Math.round(Math.min(startX, endX) / canvas.width * 999),
                        y1: Math.round(Math.min(startY, endY) / canvas.height * 999),
                        x2: Math.round(Math.max(startX, endX) / canvas.width * 999),
                        y2: Math.round(Math.max(startY, endY) / canvas.height * 999)
                    }
                };
            } else {
                annotation = {
                    id: Date.now(),
                    type: 'polygon',
                    color: currentColor,
                    lanes: autoDetectedLanes,
                    timestamp_start_ms: drawingStartTime,
                    timestamp_end_ms: timestampEnd,
                    points: polygonPoints,
                    points_normalized: polygonPoints.map(p => ({
                        x: Math.round(p.x / canvas.width * 999),
                        y: Math.round(p.y / canvas.height * 999)
                    }))
                };
            }

            if (currentTool === 'rectangle' && annotation.bbox.width > 10 && annotation.bbox.height > 10) {
                annotations.push(annotation);
            } else if (currentTool === 'polygon' && polygonPoints.length > 5) {
                annotations.push(annotation);
            }

            drawingStartTime = null;
            redrawAnnotations();
            updateAnnotationsList();
            polygonPoints = [];
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDrawing) {
                isDrawing = false;
                polygonPoints = [];
                redrawAnnotations();
            }
            hideLaneTooltip();
        });

        function showLaneTooltip(mouseX, mouseY, lanes) {
            const tooltip = document.getElementById('laneTooltip');
            if (lanes.length > 0) {
                tooltip.textContent = `Lane ${lanes.join(', ')}`;
                tooltip.classList.remove('outside');
            } else {
                tooltip.textContent = 'Outside';
                tooltip.classList.add('outside');
            }
            tooltip.style.left = mouseX + 'px';
            tooltip.style.top = mouseY + 'px';
            tooltip.style.display = 'block';
        }

        function hideLaneTooltip() {
            document.getElementById('laneTooltip').style.display = 'none';
        }

        function redrawAnnotations() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let ann of annotations) {
                ctx.strokeStyle = ann.color;
                ctx.lineWidth = 3;
                if (ann.type === 'rectangle') {
                    ctx.strokeRect(ann.bbox.x, ann.bbox.y, ann.bbox.width, ann.bbox.height);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(ann.points[0].x, ann.points[0].y);
                    for (let point of ann.points) {
                        ctx.lineTo(point.x, point.y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
            }
        }

        function updateAnnotationsList() {
            const list = document.getElementById('annotationsList');
            document.getElementById('annotationCount').textContent = annotations.length;
            if (annotations.length === 0) {
                list.innerHTML = '<p class="empty-state">Draw on the image to create annotations</p>';
                return;
            }
            list.innerHTML = annotations.map((ann, index) => `
                <div class="annotation-item">
                    <button class="delete-btn" onclick="deleteAnnotation(${index})">x</button>
                    <div class="time">${formatTimeRange(ann.timestamp_start_ms, ann.timestamp_end_ms)}</div>
                    <div class="type">${ann.type} - ${ann.lanes.length > 0 ? ann.lanes.join(', ') : 'no lanes'}</div>
                </div>
            `).join('');
        }

        function deleteAnnotation(index) {
            annotations.splice(index, 1);
            redrawAnnotations();
            updateAnnotationsList();
        }

        function undoLast() {
            if (annotations.length > 0) {
                annotations.pop();
                redrawAnnotations();
                updateAnnotationsList();
            }
        }

        function clearAnnotations() {
            if (annotations.length === 0) return;
            if (confirm('Clear all annotations?')) {
                annotations = [];
                redrawAnnotations();
                updateAnnotationsList();
            }
        }

        async function toggleRecording() {
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = (e) => {
                        audioChunks.push(e.data);
                    };
                    mediaRecorder.start();
                    isRecording = true;
                    recordingStartTime = Date.now();
                    document.getElementById('recordBtn').textContent = '■ Stop';
                    document.getElementById('recordBtn').classList.add('recording');
                    document.getElementById('audioIndicator').classList.add('recording');
                    audioTimerInterval = setInterval(updateAudioTimer, 1000);
                } catch (error) {
                    alert('Could not access microphone: ' + error.message);
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                clearInterval(audioTimerInterval);
                document.getElementById('recordBtn').textContent = '● Rec';
                document.getElementById('recordBtn').classList.remove('recording');
                document.getElementById('audioIndicator').classList.remove('recording');
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        }

        function updateAudioTimer() {
            if (!recordingStartTime) return;
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('audioTime').textContent = `${minutes}:${seconds}`;
        }

        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function formatTimeRange(startMs, endMs) {
            if (startMs === null || endMs === null) {
                return 'No timestamp';
            }
            return `${formatTime(startMs)} → ${formatTime(endMs)}`;
        }

        async function exportSession() {
            if (!currentSample) {
                alert('No sample loaded');
                return;
            }
            if (annotations.length === 0) {
                alert('No annotations to export. Draw some regions first.');
                return;
            }
            if (isRecording) {
                await stopRecordingForExport();
            }
            // Capture current layout settings for reconstruction
            const root = document.documentElement;
            const style = getComputedStyle(root);
            const eyetrackingEnabled = !document.body.classList.contains('eyetracking-disabled');
            const layoutSettings = {
                eyetracking_enabled: eyetrackingEnabled,
                apriltags: {
                    enabled: eyetrackingEnabled,
                    size_px: parseInt(style.getPropertyValue('--tag-size')) || 60,
                    margin_px: parseInt(style.getPropertyValue('--tag-margin')) || 0
                },
                pad_image: {
                    width_px: parseInt(style.getPropertyValue('--pad-width')) || null,
                    height_px: style.getPropertyValue('--pad-height').trim() === 'auto' ? null : parseInt(style.getPropertyValue('--pad-height'))
                },
                layout: {
                    tracked_padding_px: parseInt(style.getPropertyValue('--tracked-padding')) || 0
                }
            };

            const sessionData = {
                session_id: `session_${Date.now()}`,
                timestamp: new Date().toISOString(),
                sample: currentSample,
                image_dimensions: {
                    width: canvas.width,
                    height: canvas.height
                },
                layout_settings: layoutSettings,
                annotations: JSON.parse(JSON.stringify(annotations)),
                audio: null
            };
            if (audioChunks.length > 0) {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const reader = new FileReader();
                reader.readAsDataURL(audioBlob);
                reader.onloadend = () => {
                    sessionData.audio = {
                        format: 'webm',
                        data_base64: reader.result.split(',')[1],
                        duration_ms: sessionData.recording_duration_ms || null
                    };
                    downloadSession(sessionData);
                };
            } else {
                downloadSession(sessionData);
            }
        }

        function stopRecordingForExport() {
            return new Promise((resolve) => {
                if (!isRecording || !mediaRecorder) {
                    resolve();
                    return;
                }
                const duration = Date.now() - recordingStartTime;
                mediaRecorder.onstop = () => {
                    isRecording = false;
                    clearInterval(audioTimerInterval);
                    document.getElementById('recordBtn').textContent = '● Rec';
                    document.getElementById('recordBtn').classList.remove('recording');
                    document.getElementById('audioIndicator').classList.remove('recording');
                    window.lastRecordingDuration = duration;
                    resolve();
                };
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            });
        }

        async function downloadSession(data) {
            try {
                const response = await fetch('/api/save-annotation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                const result = await response.json();
                alert(`Saved ${data.annotations.length} annotations${result.audio_saved ? ' with audio' : ''} to server.\n\nTotal sessions: ${result.total_sessions}`);
            } catch (error) {
                console.error('Error saving to server:', error);
                if (confirm(`Could not save to server: ${error.message}\n\nDownload as local file instead?`)) {
                    const json = JSON.stringify(data, null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `pad_annotation_${data.sample.drug_name}_${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }
        }

        function startNewSession() {
            if (annotations.length > 0 || audioChunks.length > 0) {
                if (!confirm('This will clear all annotations and audio. Continue?')) {
                    return;
                }
            }
            if (isRecording) {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                isRecording = false;
                clearInterval(audioTimerInterval);
            }
            annotations = [];
            audioChunks = [];
            recordingStartTime = null;
            document.getElementById('recordBtn').textContent = '● Rec';
            document.getElementById('recordBtn').classList.remove('recording');
            document.getElementById('audioIndicator').classList.remove('recording');
            document.getElementById('audioTime').textContent = '00:00';
            redrawAnnotations();
            updateAnnotationsList();
        }

        // Settings modal
        let defaultSettings = {};

        function openSettings() {
            document.getElementById('settingsModal').classList.add('open');
            syncSettingsUI();
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('open');
            saveSettingsToLocalStorage();
        }

        function syncSettingsUI() {
            // Read current CSS values and sync to sliders
            const root = document.documentElement;
            const style = getComputedStyle(root);

            // Eye-tracking enabled
            const eyetrackingEnabled = !document.body.classList.contains('eyetracking-disabled');
            document.getElementById('eyetrackingEnabled').checked = eyetrackingEnabled;
            document.getElementById('apriltagSettings').style.display = eyetrackingEnabled ? 'block' : 'none';

            const tagSize = parseInt(style.getPropertyValue('--tag-size')) || 60;
            const tagMargin = parseInt(style.getPropertyValue('--tag-margin')) || 0;
            const padWidth = parseInt(style.getPropertyValue('--pad-width')) || 730;
            const padHeight = style.getPropertyValue('--pad-height').trim();
            const trackedPadding = parseInt(style.getPropertyValue('--tracked-padding')) || 0;

            document.getElementById('tagSize').value = tagSize;
            document.getElementById('tagSizeValue').textContent = tagSize + 'px';

            document.getElementById('tagMargin').value = tagMargin;
            document.getElementById('tagMarginValue').textContent = tagMargin + 'px';

            document.getElementById('padWidth').value = padWidth;
            document.getElementById('padWidthValue').textContent = padWidth + 'px';

            const heightAuto = padHeight === 'auto' || !padHeight;
            document.getElementById('padHeightAuto').checked = heightAuto;
            document.getElementById('padHeightRow').style.display = heightAuto ? 'none' : 'flex';
            if (!heightAuto) {
                const h = parseInt(padHeight) || 1220;
                document.getElementById('padHeight').value = h;
                document.getElementById('padHeightValue').textContent = h + 'px';
            }

            document.getElementById('trackedPadding').value = trackedPadding;
            document.getElementById('trackedPaddingValue').textContent = trackedPadding + 'px';
        }

        function applySettingChange(setting, value) {
            const root = document.documentElement;

            switch (setting) {
                case 'tagSize':
                    const tagMargin = parseInt(document.getElementById('tagMargin').value) || 0;
                    root.style.setProperty('--tag-size', value + 'px');
                    root.style.setProperty('--tag-offset', (value + tagMargin) + 'px');
                    document.getElementById('tagSizeValue').textContent = value + 'px';
                    break;
                case 'tagMargin':
                    const tagSize = parseInt(document.getElementById('tagSize').value) || 60;
                    root.style.setProperty('--tag-margin', value + 'px');
                    root.style.setProperty('--tag-offset', (tagSize + value) + 'px');
                    document.getElementById('tagMarginValue').textContent = value + 'px';
                    break;
                case 'padWidth':
                    root.style.setProperty('--pad-width', value + 'px');
                    document.getElementById('padWidthValue').textContent = value + 'px';
                    break;
                case 'padHeight':
                    root.style.setProperty('--pad-height', value + 'px');
                    document.getElementById('padHeightValue').textContent = value + 'px';
                    break;
                case 'padHeightAuto':
                    const autoChecked = document.getElementById('padHeightAuto').checked;
                    document.getElementById('padHeightRow').style.display = autoChecked ? 'none' : 'flex';
                    root.style.setProperty('--pad-height', autoChecked ? 'auto' : document.getElementById('padHeight').value + 'px');
                    break;
                case 'trackedPadding':
                    root.style.setProperty('--tracked-padding', value + 'px');
                    document.getElementById('trackedPaddingValue').textContent = value + 'px';
                    break;
                case 'eyetrackingEnabled':
                    const enabled = document.getElementById('eyetrackingEnabled').checked;
                    if (enabled) {
                        document.body.classList.remove('eyetracking-disabled');
                    } else {
                        document.body.classList.add('eyetracking-disabled');
                    }
                    document.getElementById('apriltagSettings').style.display = enabled ? 'block' : 'none';
                    break;
            }
        }

        function resetSettings() {
            if (confirm('Reset all settings to default values from config.yaml?')) {
                localStorage.removeItem('padAnnotationSettings');
                loadConfig().then(() => {
                    syncSettingsUI();
                });
            }
        }

        function saveSettingsToLocalStorage() {
            const settings = {
                eyetrackingEnabled: document.getElementById('eyetrackingEnabled').checked,
                tagSize: parseInt(document.getElementById('tagSize').value),
                tagMargin: parseInt(document.getElementById('tagMargin').value),
                padWidth: parseInt(document.getElementById('padWidth').value),
                padHeightAuto: document.getElementById('padHeightAuto').checked,
                padHeight: parseInt(document.getElementById('padHeight').value),
                trackedPadding: parseInt(document.getElementById('trackedPadding').value)
            };
            localStorage.setItem('padAnnotationSettings', JSON.stringify(settings));
        }

        function loadSettingsFromLocalStorage() {
            const saved = localStorage.getItem('padAnnotationSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                const root = document.documentElement;

                // Eye-tracking enabled/disabled
                if (settings.eyetrackingEnabled !== undefined) {
                    if (settings.eyetrackingEnabled) {
                        document.body.classList.remove('eyetracking-disabled');
                    } else {
                        document.body.classList.add('eyetracking-disabled');
                    }
                }

                if (settings.tagSize) {
                    root.style.setProperty('--tag-size', settings.tagSize + 'px');
                }
                if (settings.tagMargin !== undefined) {
                    root.style.setProperty('--tag-margin', settings.tagMargin + 'px');
                }
                if (settings.tagSize || settings.tagMargin !== undefined) {
                    const size = settings.tagSize || 60;
                    const margin = settings.tagMargin || 0;
                    root.style.setProperty('--tag-offset', (size + margin) + 'px');
                }
                if (settings.padWidth) {
                    root.style.setProperty('--pad-width', settings.padWidth + 'px');
                }
                if (settings.padHeightAuto !== undefined) {
                    root.style.setProperty('--pad-height', settings.padHeightAuto ? 'auto' : (settings.padHeight + 'px'));
                }
                if (settings.trackedPadding !== undefined) {
                    root.style.setProperty('--tracked-padding', settings.trackedPadding + 'px');
                }
            }
        }

        // Bind slider events
        document.getElementById('eyetrackingEnabled').addEventListener('change', () => applySettingChange('eyetrackingEnabled'));
        document.getElementById('tagSize').addEventListener('input', (e) => applySettingChange('tagSize', parseInt(e.target.value)));
        document.getElementById('tagMargin').addEventListener('input', (e) => applySettingChange('tagMargin', parseInt(e.target.value)));
        document.getElementById('padWidth').addEventListener('input', (e) => applySettingChange('padWidth', parseInt(e.target.value)));
        document.getElementById('padHeight').addEventListener('input', (e) => applySettingChange('padHeight', parseInt(e.target.value)));
        document.getElementById('padHeightAuto').addEventListener('change', () => applySettingChange('padHeightAuto'));
        document.getElementById('trackedPadding').addEventListener('input', (e) => applySettingChange('trackedPadding', parseInt(e.target.value)));

        // Close modal on overlay click
        document.getElementById('settingsModal').addEventListener('click', (e) => {
            if (e.target.id === 'settingsModal') closeSettings();
        });

        // Initialize app
        async function init() {
            await loadConfig();
            loadSettingsFromLocalStorage(); // Apply saved settings after config
            await loadManifest();
        }

        init();
    </script>
</body>
</html>
